<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Counting residues · JuliaForBioinformatics</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaForBioinformatics</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Introduction</span><ul><li><a class="toctext" href="../01_Introduction/">Introduction</a></li><li><a class="toctext" href="../02_DataStructures/">Data Structures</a></li><li><a class="toctext" href="../03_Files_Homework/">HOMEWORK: Working with Files</a></li></ul></li><li><span class="toctext">Advance</span><ul><li><a class="toctext" href="../04_HowJuliaWorks/">How Julia works?</a></li><li><a class="toctext" href="../05_DefiningTypes/">Defining your own types</a></li><li><a class="toctext" href="../06_Strings/">Working with Strings</a></li><li><a class="toctext" href="../07_Stats/">Statistics</a></li><li><a class="toctext" href="../08_Packages_Homework/">HOMEWORK: Packages</a></li></ul></li><li><span class="toctext">Bioinformatics</span><ul><li><a class="toctext" href="../09_MSA/">Multiple Sequence Alignments</a></li><li class="current"><a class="toctext" href>Counting residues</a><ul class="internal"><li><a class="toctext" href="#Plotting-counts-1">Plotting counts</a></li><li><a class="toctext" href="#Functions-taking-counts-and-probabilities-1">Functions taking counts and probabilities</a></li><li><a class="toctext" href="#Multivariate-mutual-information-1">Multivariate mutual information</a></li></ul></li><li><a class="toctext" href="../11_PDB/">MSA and structures</a></li></ul></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li>Bioinformatics</li><li><a href>Counting residues</a></li></ul><a class="edit-page" href="https://github.com/diegozea/JuliaForBioinformatics/blob/master/src/Bioinformatics/10_Information.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Counting residues</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Counting-residues-1" href="#Counting-residues-1">Counting residues</a></h1><p><a href="https://mybinder.org/v2/gh/diegozea/JuliaForBioinformatics/gh-pages?filepath=dev/notebooks/10_Information.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/diegozea/JuliaForBioinformatics/blob/gh-pages/dev/notebooks/10_Information.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>MIToS was designed to perform fast counting of residues. To achieve that, each <code>Residue</code> is encoded as an integer that can be used to index.</p><pre><code class="language-">using MIToS.MSA
res = Residue(&#39;C&#39;)</code></pre><pre><code class="language-">Int(res)</code></pre><p>Let&#39;s count residues in the <em>UBA domain</em> Pfam family.</p><pre><code class="language-">using MIToS.Pfam
const msa_file = downloadpfam(&quot;PF16577&quot;)</code></pre><pre><code class="language-">const msa = read(msa_file, Stockholm)</code></pre><p>We can access the MSA as a matrix to get a particular column or sequence:</p><pre><code class="language-julia">msa[:, column]
msa[sequence, :]</code></pre><pre><code class="language-">col_i = msa[:, 10]</code></pre><p>MIToS Information module has functions to get residue frequencies (counts or fractions) and to return contingency tables:</p><pre><code class="language-">using MIToS.Information</code></pre><pre><code class="language-">Ni = count(col_i)</code></pre><pre><code class="language-">Pi = probabilities(col_i)</code></pre><p><code>Counts</code> and <code>Probabilities</code> objects wrap a <code>ContingencyTable</code>:</p><pre><code class="language-">Pi.table</code></pre><p>They can be quickly indexed by using <code>Residue</code>s:</p><pre><code class="language-">Pi[Residue(&#39;P&#39;)]</code></pre><p>You can create a bidimensional <code>ContingencyTable</code> by using two MSA columns or sequences (there is no limit to the number of dimensions):</p><pre><code class="language-">col_j = msa[:, 15]

Nij = count(col_i, col_j)</code></pre><pre><code class="language-">Nij[Residue(&#39;P&#39;), Residue(&#39;R&#39;)]</code></pre><p>You can also get probabilities by normalizing counts:</p><pre><code class="language-">Pij = normalize(Nij.table)</code></pre><pre><code class="language-">Pij[Residue(&#39;P&#39;), Residue(&#39;R&#39;)]</code></pre><h2><a class="nav-anchor" id="Plotting-counts-1" href="#Plotting-counts-1">Plotting counts</a></h2><p>We use a <code>heatmap</code> to plot a bidimensional table:</p><pre><code class="language-">using Plots
gr()</code></pre><p>We can list the available color libraries:</p><pre><code class="language-">clibraries()</code></pre><p>Visualize the color maps defined in a library:</p><pre><code class="language-">showlibrary(:Plots)</code></pre><p>And select the color library we want to use:</p><pre><code class="language-">clibrary(:cmocean)</code></pre><p>For this plot, we use the interactive <em>Plotly</em> backend</p><pre><code class="language-">plotlyjs()</code></pre><p>We need a vector of strings for the ticks labels...</p><pre><code class="language-">x = string.(Residue.(UngappedAlphabet()))</code></pre><p>...because <code>xticks</code> and <code>xticks</code> keyword arguments take a tuple: <code>(positions, labels)</code></p><pre><code class="language-">heatmap(Nij,
		color=:tempo,
		ratio=:equal,
		xticks=(1:length(x), x),
		yticks=(1:length(x), x))</code></pre><h2><a class="nav-anchor" id="Functions-taking-counts-and-probabilities-1" href="#Functions-taking-counts-and-probabilities-1">Functions taking counts and probabilities</a></h2><p>Information defines different functions that take contingency tables as an input, for example:</p><pre><code class="language-">entropy(Ni)</code></pre><pre><code class="language-">mutual_information(Nij)</code></pre><h3><a class="nav-anchor" id="Conservation-1" href="#Conservation-1">Conservation</a></h3><p>You can use the MIToS&#39; Information module to calculate the Shannon entropy of each MSA column:</p><pre><code class="language-">using MIToS.Information

const alphabet = UngappedAlphabet()</code></pre><p>You also have <code>GappedAlphabet</code> and <code>ReducedAlphabet</code>:</p><pre><code class="language-">ReducedAlphabet(&quot;(AILMV)(RHK)(NQST)(DE)(FWY)CGP&quot;)</code></pre><p>Empty contingency tables can be defined by using <code>ContingencyTable(element_type, Val{dimensions}, alphabet)</code>:</p><pre><code class="language-">const table = ContingencyTable(Int, Val{1}, alphabet)</code></pre><p>The <code>mapcolfreq!</code>, <code>mapseqfreq!</code>, <code>mapcolpairfreq!</code> and <code>mapseqpairfreq!</code> functions from the Information module apply a function on the table filled using each column, sequence, column pair or sequence pair of the MSA, respectively:</p><pre><code class="language-">Hx = mapcolfreq!(entropy, msa, Counts(table))</code></pre><p>We use <strong>Plots.jl</strong> to visualize the entropy of each column to find variable and conserved regions</p><pre><code class="language-">gr()</code></pre><pre><code class="language-">plot_entropy = plot(vec(Hx),
					color=:orange,
					fill=0,
					fillalpha=0.5,
					legend=false,
					ylab=&quot;Entropy&quot;)</code></pre><pre><code class="language-">plot_msa = plot(msa, legend=false)</code></pre><pre><code class="language-">plot(plot_entropy,
	 plot_msa,
	 layout=grid(2, 1, heights=[0.2, 0.8]),
	 link=:x)</code></pre><h2><a class="nav-anchor" id="Multivariate-mutual-information-1" href="#Multivariate-mutual-information-1">Multivariate mutual information</a></h2><p>We are going to measure mutual information in MSA column triplets. We use Julia parallelism because the number of combinations is high.</p><pre><code class="language-julia">using Distributed</code></pre><pre><code class="language-julia">nprocs()</code></pre><pre><code class="language-none">1</code></pre><pre><code class="language-julia">addprocs(3)</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 2
 3
 4</code></pre><pre><code class="language-julia">nprocs()</code></pre><pre><code class="language-none">4</code></pre><p>We are going to use <a href="https://github.com/JuliaMath/Combinatorics.jl">Combinatorics</a> everywhere (in all the process) to get a generator of the combinations and <a href="https://github.com/timholy/ProgressMeter.jl">ProgressMeter</a> to see the progress of the parallel loop.</p><pre><code class="language-">@everywhere using Combinatorics
@everywhere using ProgressMeter
@everywhere using MIToS.MSA
@everywhere using MIToS.Information</code></pre><h4><a class="nav-anchor" id="Exercise-1-1" href="#Exercise-1-1">Exercise 1</a></h4><p>Fill the missing parts of the function to calculate mutual information between MSA columns i, j and k.</p><pre><code class="language-">function parallel_mmi(msa)
	ncols = ncolumns(msa)
	triplets = combinations(1:ncols, 3)
	@showprogress pmap(triplets) do (i, j, k)
#           ...to complete...
#           (i, j, k) =&gt; ...to complete...
	end
end</code></pre><pre><code class="language-">mi_values = parallel_mmi(msa)</code></pre><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../09_MSA/"><span class="direction">Previous</span><span class="title">Multiple Sequence Alignments</span></a><a class="next" href="../11_PDB/"><span class="direction">Next</span><span class="title">MSA and structures</span></a></footer></article></body></html>
