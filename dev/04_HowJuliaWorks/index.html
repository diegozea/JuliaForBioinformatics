<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How Julia works? · JuliaForBioinformatics</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaForBioinformatics</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Introduction</span><ul><li><a class="toctext" href="../01_Introduction/">Introduction</a></li><li><a class="toctext" href="../02_DataStructures/">Data Structures</a></li><li><a class="toctext" href="../03_Files_Homework/">HOMEWORK: Working with Files</a></li></ul></li><li><span class="toctext">Advance</span><ul><li class="current"><a class="toctext" href>How Julia works?</a><ul class="internal"><li><a class="toctext" href="#Type-system-1">Type system</a></li></ul></li><li><a class="toctext" href="../06_Strings/">Working with Strings</a></li><li><a class="toctext" href="../08_Stats/">Statistics</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Advance</li><li><a href>How Julia works?</a></li></ul><a class="edit-page" href="https://github.com/diegozea/JuliaForBioinformatics/blob/master/src/Advance/04_HowJuliaWorks.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>How Julia works?</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="How-Julia-works?-1" href="#How-Julia-works?-1">How Julia works?</a></h1><p><a href="https://mybinder.org/v2/gh/diegozea/JuliaForBioinformatics/gh-pages?filepath=dev/notebooks/04_HowJuliaWorks.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/diegozea/JuliaForBioinformatics/blob/gh-pages/dev/notebooks/04_HowJuliaWorks.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><h2><a class="nav-anchor" id="Type-system-1" href="#Type-system-1">Type system</a></h2><p>Until now, we have not used type annotations, but Julia has a rich type system. Julia is an optionally- and dynamically-typed programming language. That means that you can change the type of a variable...</p><pre><code class="language-julia">a = 10
typeof(a)</code></pre><pre><code class="language-none">Int64</code></pre><pre><code class="language-julia">a = true
typeof(a)</code></pre><pre><code class="language-none">Bool</code></pre><p>... and that type annotations are optional. You can use type annotations to:</p><ul><li>make a program more robust (type checking)</li></ul><pre><code class="language-julia">a::Bool # type assertion</code></pre><pre><code class="language-none">true</code></pre><pre><code class="language-">a::Int</code></pre><ul><li>optimize code by giving a hint to the compiler</li><li>documment the code and use multiple dispatch</li></ul><pre><code class="language-julia"># function_name(arg::ArgumentType)::ReturnType = function_body
first_character(str::AbstractString)::Char = str[1]</code></pre><pre><code class="language-none">first_character (generic function with 1 method)</code></pre><pre><code class="language-julia">character = first_character(&quot;ABC&quot;)</code></pre><pre><code class="language-none">&#39;A&#39;: ASCII/Unicode U+0041 (category Lu: Letter, uppercase)</code></pre><pre><code class="language-">character = first_character(10_000)</code></pre><h3><a class="nav-anchor" id="Type-hierarchy-1" href="#Type-hierarchy-1">Type hierarchy</a></h3><p>Any Julia object has a type that belongs to a fully connected type graph. There are abstract and concrete types. Concrete types are final, i.e. they cannot have subtypes, while abstract types can have multiple subtypes but only one supertype.</p><pre><code class="language-julia">using JuliaForBioinformatics
show_type_tree(Number)</code></pre><pre><code class="language-none">Any
    Number
        Complex
        Real
            AbstractFloat
                BigFloat
                Float16
                Float32
                Float64
            AbstractIrrational
                Irrational
            Integer
                Bool
                Signed
                    BigInt
                    Int128
                    Int16
                    Int32
                    Int64
                    Int8
                Unsigned
                    UInt128
                    UInt16
                    UInt32
                    UInt64
                    UInt8
            Rational
            StatsBase.TestStat</code></pre><p>In Julia, all values are instances of the abstract type <code>Any</code>.</p><p>The functions supertype and subtypes are useful to navegate the type graph.</p><pre><code class="language-julia">supertype(Real)</code></pre><pre><code class="language-none">Number</code></pre><pre><code class="language-">subtypes(Real)</code></pre><p>You can use <code>isa</code> to test if an object is of a given type</p><pre><code class="language-julia">isa(&quot;I&#39;m a string&quot;, String)</code></pre><pre><code class="language-none">true</code></pre><p>And the subtype operator <code>&lt;:</code> to test if a type is a subtype of another</p><pre><code class="language-julia">String &lt;: AbstractString</code></pre><pre><code class="language-none">true</code></pre><p>You can also use <code>Union</code> of types, for example, if the possible types don&#39;t share a meaningful supertype</p><pre><code class="language-julia">String &lt;: Union{AbstractString, AbstractChar}</code></pre><pre><code class="language-none">true</code></pre><h3><a class="nav-anchor" id="Multiple-dispatch-1" href="#Multiple-dispatch-1">Multiple dispatch</a></h3><p>We can define multiple <a href="https://docs.julialang.org/en/v1/manual/methods/#Methods-1">methods</a> for a function by using different method signatures by indicating the argument types using <code>::</code> or <code>&lt;:</code>.</p><p>For example we are going to define 3 methods for the function <code>say_my_type</code>:</p><pre><code class="language-julia">say_my_type(x) = println(x, &quot; is a &quot;, typeof(x))
# say_my_type(x) is the same that say_my_type(x::Any)

say_my_type(x::Real) = println(x, &quot; is a Real number of type &quot;,  typeof(x))
say_my_type(x::Float64) = println(x, &quot; is a Float64 number&quot;)</code></pre><pre><code class="language-none">say_my_type (generic function with 3 methods)</code></pre><p>When the function is called, Julia selects the method with the most specific method signature.</p><pre><code class="language-julia">say_my_type(&#39;A&#39;) # &#39;A&#39; is a Char, a subtype of Any
say_my_type(2) # 2 is an Int, a subtype of Real
say_my_type(2.0)</code></pre><pre><code class="language-none">A is a Char
2 is a Real number of type Int64
2.0 is a Float64 number</code></pre><p><code>say_my_type(x::Real)</code> can also be written using the <code>where</code> keyword as</p><pre><code class="language-julia">say_my_type(x::T) where {T &lt;: Real} = println(x, &quot; is a Real number of type &quot;,  T)</code></pre><pre><code class="language-none">say_my_type (generic function with 3 methods)</code></pre><h3><a class="nav-anchor" id="Parametric-types-1" href="#Parametric-types-1">Parametric types</a></h3><p>Julia types can have parameters. We have already used parametric types, one of them is Array:</p><pre><code class="language-julia">cube = zeros(Int, 3, 3, 3)
typeof(cube)</code></pre><pre><code class="language-none">Array{Int64,3}</code></pre><p>Julia Arrays take two parameters, the type of the elements stored in the array and the array dimensions.</p><p>This allows to write specific methods depending on those parameters</p><pre><code class="language-julia">say_my_type(x::Array{T, 1}) where {T} = println(x, &quot; is vector with &quot;,  T, &quot; elements&quot;)
say_my_type(x::Array{T, 2}) where {T} = println(x, &quot; is matrix with &quot;,  T, &quot; elements&quot;)</code></pre><pre><code class="language-none">say_my_type (generic function with 5 methods)</code></pre><pre><code class="language-julia">say_my_type(Rational[0.5, 1, 1.5])
say_my_type(Float64[1 3 5; 2 4 6])</code></pre><pre><code class="language-none">Rational[1//2, 1//1, 3//2] is vector with Rational elements
[1.0 3.0 5.0; 2.0 4.0 6.0] is matrix with Float64 elements</code></pre><h4><a class="nav-anchor" id="Exercise-1-1" href="#Exercise-1-1">Exercise 1</a></h4><p>Add a method to <code>say_my_type</code> that prints the number of unique values of an array of characters or strings and its dimensions.</p><pre><code class="language-julia"># ... text array with ... dimensions and ... unique values ...</code></pre><h3><a class="nav-anchor" id="Which-method-is-being-used?-1" href="#Which-method-is-being-used?-1">Which method is being used?</a></h3><p>You can use the <code>@which</code> macro to ask Julia which particular method is being used</p><pre><code class="language-">@which say_my_type(2 + 0im)</code></pre><pre><code class="language-">@which say_my_type(2.0)</code></pre><h3><a class="nav-anchor" id="Julia-compiler-1" href="#Julia-compiler-1">Julia compiler</a></h3><p>Julia uses Just-in-time (JIT) compilation to achieve close to C performance. After selecting the most specific method, Julia (generally) compiles the method for the particular argument types.</p><p>Because of that, the first time a function is called, it is compiled (slow). If you call the same function a second time with the same argument types, it will use the already compiled code (fast).</p><pre><code class="language-julia">@time sum(1:10_000)</code></pre><pre><code class="language-none">50005000</code></pre><pre><code class="language-julia">@time sum(1:10_000)</code></pre><pre><code class="language-none">50005000</code></pre><p>While compilation times can be annoying sometimes, this mechanism allows Julia generality, composability and its capacity to generate efficient code for user-defined types. That&#39;s mean that you do not need to use built-in types or functions or to code some parts in C/Fortran to get a good performance like in other high-level languages.</p><p>Also, Julia represents its own code as a Julia data structure. This allows a program to transform and generate its own code, using <strong>macros</strong> and <strong>generated functions</strong>, for example, and powerful reflection capabilities to explore the internals of a program. You can read the <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">metaprogramming section of the manual</a> to learn more about this topic.</p><p><img src="../JuliaCompiler.png" alt/></p><pre><code class="language-julia">function sum_numbers(vector)
    total = 0
    for value in vector
        total += value
    end
    total
end</code></pre><pre><code class="language-none">sum_numbers (generic function with 1 method)</code></pre><p>To avoid performance issues for using a <a href="https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-global-variables-1">global variable</a> we are going to define it as a constant using the <a href="https://docs.julialang.org/en/v1/base/base/#const">const keyword.</a></p><pre><code class="language-julia">const rand_vector = rand(5)</code></pre><pre><code class="language-none">5-element Array{Float64,1}:
 0.8602589418802822 
 0.9346126171981428 
 0.9645888538576246 
 0.08155980740845692
 0.8703084387945312 </code></pre><pre><code class="language-">@code_lowered sum_numbers(rand_vector)</code></pre><pre><code class="language-">@code_typed sum_numbers(rand_vector)</code></pre><pre><code class="language-">@code_warntype sum_numbers(rand_vector)</code></pre><pre><code class="language-">@code_llvm sum_numbers(rand_vector)</code></pre><pre><code class="language-">@code_native sum_numbers(rand_vector)</code></pre><h4><a class="nav-anchor" id="Exercise-2-1" href="#Exercise-2-1">Exercise 2</a></h4><p>Modify the <code>sum_numbers</code> function to make it <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Write-%22type-stable%22-functions-1">type stable</a> by using <code>zero</code> and <code>eltype</code>. Then compare the output of the previous <code>@code_</code>* macros.</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../03_Files_Homework/"><span class="direction">Previous</span><span class="title">HOMEWORK: Working with Files</span></a><a class="next" href="../06_Strings/"><span class="direction">Next</span><span class="title">Working with Strings</span></a></footer></article></body></html>
