<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Structures · JuliaForBioinformatics</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaForBioinformatics</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Introduction</span><ul><li><a class="toctext" href="../01_Introduction/">Introduction</a></li><li class="current"><a class="toctext" href>Data Structures</a><ul class="internal"><li><a class="toctext" href="#Arrays-1">Arrays</a></li><li><a class="toctext" href="#Dictionaries-and-pairs-1">Dictionaries and pairs</a></li><li><a class="toctext" href="#Tuples-1">Tuples</a></li><li><a class="toctext" href="#Sets-1">Sets</a></li></ul></li><li><a class="toctext" href="../03_Files/">Working with Files</a></li><li><a class="toctext" href="../04_Stats/">Statistics</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Introduction</li><li><a href>Data Structures</a></li></ul><a class="edit-page" href="https://github.com/diegozea/JuliaForBioinformatics/blob/master/src/Introduction/02_DataStructures.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Data Structures</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Data-Structures-1" href="#Data-Structures-1">Data Structures</a></h1><p><a href="https://mybinder.org/v2/gh/diegozea/JuliaForBioinformatics/gh-pages?filepath=dev/notebooks/02_DataStructures.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/diegozea/JuliaForBioinformatics/blob/gh-pages/dev/notebooks/02_DataStructures.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><h2><a class="nav-anchor" id="Arrays-1" href="#Arrays-1">Arrays</a></h2><p>Julia has a nice and flexible array interface. Arrays can have an arbitrary number of dimensions. Let&#39;s define a one-dimetional array (i.e. a vector):</p><pre><code class="language-julia">vector = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]</code></pre><pre><code class="language-none">6-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0
 5.0
 6.0</code></pre><p>The first index of an array in Julia is <code>1</code>:</p><pre><code class="language-julia">vector[1]</code></pre><pre><code class="language-none">1.0</code></pre><p>You can use <code>end</code> to access the last element of an array:</p><pre><code class="language-julia">vector[end]</code></pre><pre><code class="language-none">6.0</code></pre><p>Use ranges (<code>start:end</code>) to get a slice of the array:</p><pre><code class="language-julia">vector[2:4]</code></pre><pre><code class="language-none">3-element Array{Float64,1}:
 2.0
 3.0
 4.0</code></pre><p>Julia arrays, like the strings, are iterables:</p><pre><code class="language-julia">for element in vector
	println(element)
end</code></pre><pre><code class="language-none">1.0
2.0
3.0
4.0
5.0
6.0</code></pre><h4><a class="nav-anchor" id="Exercise-1-1" href="#Exercise-1-1">Exercise 1</a></h4><p>Write a function to return the distance between two three dimensional points using a for loop and indexing the vectors.</p><pre><code class="language-julia"># distance(...</code></pre><pre><code class="language-">using Test
A = [1.25, 2.0, 3.6]
B = [-3.5, 4.7, 5.0]
@test distance(A, B) ≈ hypot((A - B)...)</code></pre><p><code>...</code> &quot;splats&quot; the values contained in an iterable collection into a function call as individual arguments, e.g:</p><pre><code class="language-julia">vector = [1, 2, 3]
hypot(vector...)  ## hypot(1, 2, 3)</code></pre><pre><code class="language-none">3.7416573867739413</code></pre><p>You can use <code>push!</code> to add one element to the end of an array</p><pre><code class="language-julia">vector = [1,2,3]</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 1
 2
 3</code></pre><pre><code class="language-julia">push!(vector, 4)</code></pre><pre><code class="language-none">4-element Array{Int64,1}:
 1
 2
 3
 4</code></pre><p>There are other useful <a href="https://docs.julialang.org/en/v1/base/collections/#Dequeues-1">dequeues functions</a> defined in Julia, e.g. <code>pop!</code>, <code>append!</code>.</p><p>In Julia, by convention, all the functions that modify their arguments should end with a bang, <code>!</code>, see the <a href="https://docs.julialang.org/en/v1/manual/style-guide/index.html#Append-!-to-names-of-functions-that-modify-their-arguments-1">style guide</a>.</p><h3><a class="nav-anchor" id="Vectorized-operations-1" href="#Vectorized-operations-1">Vectorized operations</a></h3><p>You can use a dot, <code>.</code>,  to indicate that a function, e.g. <code>log.(...)</code>, or operator, e.g. <code>.^</code>,  should be applied element by element, see <a href="https://docs.julialang.org/en/v1/manual/functions/#man-vectorized-1">dot syntax</a>:</p><pre><code class="language-julia">a = [1, -2, -3]
b = [-2, -4, 0]
a .* b</code></pre><pre><code class="language-none">3-element Array{Int64,1}:
 -2
  8
  0</code></pre><p>This notation allows vectorizing any function, even element-wise functions defined by the user:</p><pre><code class="language-julia">fun(x) = 3.45x + 4.76

fun.(sin.(a))</code></pre><pre><code class="language-none">3-element Array{Float64,1}:
 7.663074897587243 
 1.6229238774513979
 4.273135972193458 </code></pre><p>Multiple vectorized operations get <a href="https://julialang.org/blog/2017/01/moredots">fused in a single loop</a> without temporal arrays.</p><h3><a class="nav-anchor" id="Comprehensions-1" href="#Comprehensions-1">Comprehensions</a></h3><p>You can use <a href="https://docs.julialang.org/en/v1/manual/arrays/#Comprehensions-1">comprehensions</a> to create arrays and perform some operation</p><pre><code class="language-julia">[ 2x for x in 1:10 if x % 2 == 0 ]</code></pre><pre><code class="language-none">5-element Array{Int64,1}:
  4
  8
 12
 16
 20</code></pre><h3><a class="nav-anchor" id="Matrices-1" href="#Matrices-1">Matrices</a></h3><p>Matrices, bidimentional arrays, can be defined with the following notation:</p><pre><code class="language-julia">matrix = [ 1.0 4.0 7.0
           2.0 5.0 8.0
		   3.0 6.0 9.0 ]</code></pre><pre><code class="language-none">3×3 Array{Float64,2}:
 1.0  4.0  7.0
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><p>You can use linear indexing (Julia arrays are stored in column major order) to access an element</p><pre><code class="language-julia">matrix[9]</code></pre><pre><code class="language-none">9.0</code></pre><p>Or using one index by dimension, i.e. <code>matrix[row_index, col_index]</code> :</p><pre><code class="language-julia">matrix[3, 3]</code></pre><pre><code class="language-none">9.0</code></pre><p>You can also use ranges and <code>end</code>. The colon, <code>:</code>, means that all the indices from that dimension should be used:</p><pre><code class="language-julia">matrix[2:end, :]</code></pre><pre><code class="language-none">2×3 Array{Float64,2}:
 2.0  5.0  8.0
 3.0  6.0  9.0</code></pre><h4><a class="nav-anchor" id="Comprehensions-2" href="#Comprehensions-2">Comprehensions</a></h4><p>You can also use comprehensions to create matrices. In fact, you can create array of any desired dimension:</p><pre><code class="language-julia">[ x + y for x in 1:5, y in 1:10 ]</code></pre><pre><code class="language-none">5×10 Array{Int64,2}:
 2  3  4  5   6   7   8   9  10  11
 3  4  5  6   7   8   9  10  11  12
 4  5  6  7   8   9  10  11  12  13
 5  6  7  8   9  10  11  12  13  14
 6  7  8  9  10  11  12  13  14  15</code></pre><h2><a class="nav-anchor" id="Dictionaries-and-pairs-1" href="#Dictionaries-and-pairs-1">Dictionaries and pairs</a></h2><p>Dictionaries (hash tables) stores key =&gt; values pairs:</p><pre><code class="language-julia">dictionary = Dict(&#39;A&#39; =&gt; &#39;T&#39;, &#39;C&#39; =&gt; &#39;G&#39;, &#39;T&#39; =&gt; &#39;A&#39;, &#39;G&#39; =&gt; &#39;C&#39;)</code></pre><pre><code class="language-none">Dict{Char,Char} with 4 entries:
  &#39;A&#39; =&gt; &#39;T&#39;
  &#39;G&#39; =&gt; &#39;C&#39;
  &#39;T&#39; =&gt; &#39;A&#39;
  &#39;C&#39; =&gt; &#39;G&#39;</code></pre><p>You can get a value by indexing with the key:</p><pre><code class="language-julia">dictionary[&#39;A&#39;]</code></pre><pre><code class="language-none">&#39;T&#39;: ASCII/Unicode U+0054 (category Lu: Letter, uppercase)</code></pre><p>If the key is not present in the dictionary, an error is raised:</p><pre><code class="language-">dictionary[&#39;N&#39;]</code></pre><p>The function <code>get</code> allows to specify and default value that is returned is the key is absent in the dictionary:</p><pre><code class="language-julia">get(dictionary, &#39;N&#39;, &#39;-&#39;)</code></pre><pre><code class="language-none">&#39;-&#39;: ASCII/Unicode U+002d (category Pd: Punctuation, dash)</code></pre><p>A nice thing about hash tables (dictionary keys, sets) is that test membership is <span>$O(1)$</span> while it is <span>$O(N)$</span> in lists/vectors/arrays:</p><pre><code class="language-julia">&#39;N&#39; in keys(dictionary)</code></pre><pre><code class="language-none">false</code></pre><p>A dictionary gives pairs when it is iterated:</p><pre><code class="language-julia">for pair in dictionary
	println(&quot;pair: &quot;, pair)  ## each pair is key =&gt; value
	println(&quot;key: &quot;, pair.first)  ## pair.first == pair[1]
	println(&quot;value: &quot;, pair.second)  ## pair.second == pair[2]
end</code></pre><pre><code class="language-none">pair: &#39;A&#39; =&gt; &#39;T&#39;
key: A
value: T
pair: &#39;G&#39; =&gt; &#39;C&#39;
key: G
value: C
pair: &#39;T&#39; =&gt; &#39;A&#39;
key: T
value: A
pair: &#39;C&#39; =&gt; &#39;G&#39;
key: C
value: G</code></pre><h2><a class="nav-anchor" id="Tuples-1" href="#Tuples-1">Tuples</a></h2><p>Tuples are immutable collections, while arrays are mutable:</p><pre><code class="language-julia">point = [1.0, 2.0, 3.0]  ## vector
point[1] = 10.0
point</code></pre><pre><code class="language-none">3-element Array{Float64,1}:
 10.0
  2.0
  3.0</code></pre><pre><code class="language-julia">point = (1.0, 2.0, 3.0)  ## tuple</code></pre><pre><code class="language-none">(1.0, 2.0, 3.0)</code></pre><pre><code class="language-">point[1] = 10.0</code></pre><p>You can index a tuple, like a vector, to get the stored element(s):</p><pre><code class="language-julia">point[1:2]</code></pre><pre><code class="language-none">(1.0, 2.0)</code></pre><p>Tuples, vectors, pairs and other iterables can be easily unpacked using an assignation:</p><pre><code class="language-julia">x, y, z = point
y</code></pre><pre><code class="language-none">2.0</code></pre><p>You can use this unpacking when iterating a dictionary:</p><pre><code class="language-julia">for (key, value) in dictionary
	println(&quot;key: &quot;, key, &quot; value: &quot;, value)
end</code></pre><pre><code class="language-none">key: A value: T
key: G value: C
key: T value: A
key: C value: G</code></pre><h4><a class="nav-anchor" id="Exercise-2-1" href="#Exercise-2-1">Exercise 2</a></h4><p>Write a function to return the reverse complement of a DNA sequence (string) using a dictionary, the <code>join</code> function and the <code>Base.Iterators.reverse</code> iterator. It should use a &#39;N&#39; as complementary of any base different from &#39;A&#39;, &#39;C&#39;, &#39;T&#39; or &#39;G&#39;:</p><pre><code class="language-julia"># reverse_complement(...</code></pre><pre><code class="language-">@assert reverse_complement(&quot;ACTGGTCCCNT&quot;) == &quot;ANGGGACCAGT&quot;</code></pre><h3><a class="nav-anchor" id="Named-tuples-1" href="#Named-tuples-1">Named tuples</a></h3><p>They can be an easy and fast way to store data:</p><pre><code class="language-julia">point = (x=1.0, y=2.0, z=3.0)  ## named tuple</code></pre><pre><code class="language-none">(x = 1.0, y = 2.0, z = 3.0)</code></pre><p>You can use <code>namedtuple.name</code> to access a particular element:</p><pre><code class="language-julia">point.y</code></pre><pre><code class="language-none">2.0</code></pre><h2><a class="nav-anchor" id="Sets-1" href="#Sets-1">Sets</a></h2><p>You can use <code>Set</code> to represent a set of unique elements:</p><pre><code class="language-julia">set = Set([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])</code></pre><pre><code class="language-none">Set([4, 2, 3, 1])</code></pre><p>Test membership is <span>$O(1)$</span></p><pre><code class="language-julia">4 in set</code></pre><pre><code class="language-none">true</code></pre><p>You can get the intersection of two sets using <code>intersect</code> or <code>∩</code> (<code>\cap&lt;TAB&gt;</code>)</p><pre><code class="language-julia">set_a = Set([1, 2, 3])
set_b = Set([2, 3, 4])
set_a ∩ set_b  ## intersect(set, set_b)</code></pre><pre><code class="language-none">Set([2, 3])</code></pre><p>And the unioin of to sets using <code>union</code> or <code>∪</code> (<code>\cup&lt;TAB&gt;</code>)</p><pre><code class="language-julia">set_a ∪ set_b  ## union(set, set_b)</code></pre><pre><code class="language-none">Set([4, 2, 3, 1])</code></pre><p>The symmetric difference, i.e. disjunctive union, of two sets</p><pre><code class="language-julia">symdiff(set_a, set_b)</code></pre><pre><code class="language-none">Set([4, 1])</code></pre><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../01_Introduction/"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../03_Files/"><span class="direction">Next</span><span class="title">Working with Files</span></a></footer></article></body></html>
